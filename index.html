<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, user-scalable=no">
	<title>Readble</title>
	<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,700" rel="stylesheet">
	<link rel="stylesheet" href="main.css?6">
</head>
<body class="readble">
	<select name="" id="change-font">
		<option value="readble">Readble</option>
		<option value="g1">G1</option>
		<option value="medium">Medium</option>
	</select>
	<div class="container">
		<h1>Simple server side cache for Express.js with Node.js</h1>
		<p class="description">This blog was written by Guilherme Oenning who is a Senior Software Developer at SoftwareONE. He truly believes that learning never ends and sharing knowledge is key to growth. When not programming, he can be found running or cycling around Dublin, Ireland.</p>
		<p>Express is the most extensible web framework I’ve seen so far. The framework’s middleware architecture makes it easy to plug-in extra features with minimal effort and in a standardized way.</p>
		<p>For this article, we’ll cover a very small and simple, yet powerful and useful middleware that will help you boost your express web application performance without any external dependency.</p>

		<h2>About server side cache</h2>
		<p>Caching is a commonly used technique to improve the performance of any application, be it desktop, mobile or web. When dealing with web applications we can make good use of client-side caching using response headers that all browsers currently support. But, what if we have a complex and heavy page that takes 2 second to generate the HTML output?Even if we enable client-side cache for this page, the web server will still need to render the page for each different user accessing our web application. Think about the home page of a large news portal; do they process their HTML over and over again for each visitor?</p>
		<p>This is where server-side cache comes in handy. The goal of server side cache is responding to the same content for the same request independently of the client’s request. In our example above, the first request that reaches our server would still take 2 seconds to generate the HTML, but the following requests would hit the cache instead and the server would be able to send the response in a few milliseconds.</p>
		<p>There are many ways of doing it, it could be done with NGINX or a CDN like CloudFlare, but in this example we’ll see how to do it with Node.js and Express with minimal work and in a flexible way.</p>

		<h2>Show me the code!</h2>
		<p>Our goal here is to enable server-side cache for our application with minimal effort. So, let’s do it!</p>
		<ul>
			<li><p>Caching is a commonly used</p></li>
			<li><p>We’ll make use of memory-cache npm module</p></li>
			<li><p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ducimus incidunt ipsam reiciendis </p></li>
		</ul>
		<p>We’ll make use of memory-cache npm module in order to be able to add content to cache. Our cache middleware is the following.</p>

		<h3>Note:</h3>
		<p>Note that the above route contains two middlewares. The first one is the cache reference and the second one is the real middleware that handles the request. In this case, when the server receives the first request for this route, it will wait for 5 seconds before sending to client. But after that, consecutive calls will get the cached response body for the next 10 seconds and, of course, it will not have to wait those 5 seconds anymore.</p>
		<p>The downside is if you have something that has to be dynamic. In the above route, we have passed the current date as an argument to the view engine. The cached response body will have this same date until the cache expires (10 seconds in this case).</p>
		<p>The cool thing here is that it works for routes that responds with HTML, JSON, XML or any other content-type. It can be used to boost a simple website up to some heavy, complex, REST-based Express application.</p>
		<p>You can easily plug it into any existing Express web application by simple adding the cache middleware for each route you may want to cache.</p>
	</div>

	<script type="text/javascript">
		document.getElementById('change-font').addEventListener('change', function() {
			let target = document.getElementsByTagName('body')
			let change = this.value

			target[0].className = change
		});
	</script>
</body>
</html>